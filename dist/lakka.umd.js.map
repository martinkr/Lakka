{"version":3,"file":"lakka.umd.js","mappings":"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","sources":["webpack://lakka/webpack/universalModuleDefinition","webpack://lakka/webpack/bootstrap","webpack://lakka/webpack/runtime/define property getters","webpack://lakka/webpack/runtime/hasOwnProperty shorthand","webpack://lakka/webpack/runtime/make namespace object","webpack://lakka/./app/configuration/default.js","webpack://lakka/./app/configuration/main.js","webpack://lakka/./app/header/valid-status-code.js","webpack://lakka/./app/header/valid-cache-control.js","webpack://lakka/./app/cache/calculate-validity.js","webpack://lakka/./app/header/valid-content-type.js","webpack://lakka/./app/facade/localstorage.js","webpack://lakka/./app/cache/create-key.js","webpack://lakka/./app/header/utils/get-value.js","webpack://lakka/./app/cache/create-item.js","webpack://lakka/./app/utils/throw-invalid.js","webpack://lakka/./app/header/utils/check-value.js","webpack://lakka/./app/cache/set-item.js","webpack://lakka/./app/pattern-match/main.js","webpack://lakka/./app/api/after.js","webpack://lakka/./app/cache/check-freshness.js","webpack://lakka/./app/cache/get-item.js","webpack://lakka/./app/api/before.js","webpack://lakka/./app/api/main.js","webpack://lakka/./app/main.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lakka\"] = factory();\n\telse\n\t\troot[\"lakka\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const config = {\n\t\"include\": [],\n\t\"exclude\": [],\n\t\"minutes\": 60\n};\n\nexport default config;\n","/**\n * @module configuration/main\n * @description\n * This module provides the funcitonality to configure the lakka-cache.\n * @exports get ()\n * @exports set ()\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\n// imports\nimport defaults from './default';\nconst validProperties = [\"include\", \"exclude\", \"minutes\"];\n\nlet config = Object.assign({}, defaults);\n\n/**\n * Verifies if the arguments passed to \".set()\" are valid.\n * @param {Array} args the arguments passed to .set()\n * @return {Boolean}\n */\nconst _validArguments = (args) => {\n\n\t// no arguments\n\tif (args.length === 0) {\n\t\treturn false;\n\t}\n\t// just one argument but not an Object ...\n\tif (args.length === 1 && args[0] !== Object(args[0])) {\n\t\treturn false;\n\t}\n\n\t// just one argument which is an object: check if the object contains only valid properties\n\tif (args.length === 1 && args[0] === Object(args[0])) {\n\t\treturn Object.keys(args[0]).every((element) => validProperties.includes(element));\n\t}\n\n\t// two strings as arguments: we're checking the \"minutes\" property first\n\tif (args.length === 2 && args[0] === \"minutes\") {\n\t\tif (\n\t\t\t// should be a number or parsable to a number\n\t\t\t(typeof (Number(args[1])) === \"number\" && Number.isNaN(Number(args[1])) === false)\n\t\t\t// but not an array\n\t\t\t&& (Array.isArray(args[1]) === false)\n\t\t\t// but not a boolean\n\t\t\t&& (typeof (args[1]) !== \"boolean\")\n\t\t) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// two string arguments: check if the first one refers to a valid property\n\tif (args.length === 2 && typeof (args[0]) === \"string\" && typeof (args[1]) === \"string\") {\n\t\treturn validProperties.includes(args[0]);\n\t}\n\n\treturn false;\n};\n\n/**\n * Retrives a value for a given key or null\n * @sync\n * @private\n * @memberof configuration/main\n * @param {String} key the key for the sessionStorage item to get\n * @return {Any} the configuration value\n */\nconst _get = (key) => {\n\tif (!key || typeof (key) !== \"string\" || validProperties.includes(key) !== true) {\n\t\tthrow new Error();\n\t}\n\treturn config[key];\n}\n\n\n/**\n * Stores a key/value pair\n * @sync\n * @private\n * @memberof configuration/main\n * @param {String|Object} key the key for the value OR the configuration object\n * @param {String} [value] the value to set. Skip if the first argument is a configuraiton object\n * @return {Any} the sessionStorages response\n */\nconst _set = (key, value) => {\n\t// unique\n\tlet args = [key, value].filter((element) => element);\n\n\tif (!_validArguments(args)) {\n\t\tthrow new Error();\n\t}\n\n\t// object insted of a key-value pair: merge into current config\n\tif (args[0] === Object(args[0])) {\n\t\tconfig = Object.assign(config, args[0]);\n\t\treturn true;\n\t}\n\n\tif (key === \"include\" || key === \"exclude\") {\n\t\t// we're storing regexp for performance reasons\n\t\t/* istanbul ignore next */\n\t\tif (typeof (value) === \"string\") {\n\t\t\tvalue = new RegExp(value);\n\t\t}\n\t\t// ignore dublicates\n\t\tif (config[key].some((element) => element.source === value.source)) {\n\t\t\treturn true;\n\t\t}\n\t\tconfig[key].push(value);\n\t\treturn true;\n\t}\n\n\t// key-value pair: store\n\tconfig[key] = value;\n\n\treturn true;\n}\n\n\n\n// API\nconst api = {\n\n\t/**\n\t * Retrives a value for a given key or null\n\t * @sync\n\t * @private\n\t * @memberof configuration/main\n\t * @param {String} key the key for the sessionStorage item to get\n\t * @return {Any} the configuration value\n\t */\n\t\"get\": (key) => _get(key),\n\n\t/**\n\t * Stores a key/value pair\n\t * @sync\n\t * @private\n\t * @memberof configuration/main\n\t * @param {String|Object} key the key for the value OR the configuration object\n\t * @param {String} [value] the value to set. Skip if the first argument is a configuraiton object\n\t * @return {Any} the sessionStorages response\n\t */\n\t\"set\": (key, value) => _set(key, value)\n\n};\n\nexport default api;\n","\n/**\n * @module header/valid-status-code\n * @exports a sync function\n *\n * @description\n * Checks if the status-code of the response indicates cachable content\n *\n * 200 OK\n * \tStandard response for successful HTTP requests. The actual response will depend on the request method used. In a GET request, the response will contain an entity corresponding to the requested resource. In a POST request, the response will contain an entity describing or containing the result of the action.[8]\n * 203 Non-Authoritative Information (since HTTP/1.1)\n * \tThe server is a transforming proxy (e.g. a Web accelerator) that received a 200 OK from its origin, but is returning a modified version of the origin's response.[11][12]\n * 226 IM Used (RFC 3229)\n * \tThe server has fulfilled a request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.[17]\n *\n * TODO  think about these\n * 301 Moved Permanently\n * \tThis and all future requests should be directed to the given URI.[20]\n * 302 Found\n * 303 See Other (since HTTP/1.1)\n * \tThe response to the request can be found under another URI using the GET method.\n * 304 Not Modified (RFC 7232)\n * \tIndicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match. In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.[25]\n * 308 Permanent Redirect (RFC 7538)\n * \tThe request and all future requests should be repeated using another URI. 307 and 308 parallel the behaviors of 302 and 301, but do not allow the HTTP method to change. So, for example, submitting a form to a permanently redirected resource may continue smoothly.[30]\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\n/**\n * Checks if the status-code of the response indicates a cachable content\n * @memberof header/valid-status-code\n * @sync\n * @param {String} element the content of the Status-Code of the response\n * @return {Boolean} true if cachable\n */\nconst main = (element) => [\"200\", \"203\", \"226\"].includes(element);\n\nexport default main;","/**\n * @module cache/valid-cache-control\n * @exports a sync function\n *\n * @description\n * Checks the value of the \"Cache-Control\" HTTP-Header.\n * Checks if the Cache-Control- HTTP-Header let's us cache this request.\n *\n * Agressive cache:\n * Do not cache if\n * must-revalidate\n *\tThe cache must verify the status of the stale resources before using it and expired ones should not be used.\n * no-store\n * \tThe cache should not store anything about the client request or server response.\n * no-cache\n * \tForces caches to submit the request to the origin server for validation before releasing a cached copy.\n *\n * OBSOLETE\n * Cache if the value is:\n * only-if-cached (Request)\n * \tIndicates to not retrieve new data. The client only wishes to obtain a cached response, and should not contact the origin-server to see if a newer copy exists.\n * immutable\n *\tIndicates that the response body will not change over time.\n * public\n * \tIndicates that the response may be cached by any cache.\n * private\n * \tIndicates that the response is intended for a single user and must not be stored by a shared cache. A private cache may store the response.\n *\n * or no entry at all\n *\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\nconst ignorePattern = [\n\tnew RegExp(\"must-revalidate\"),\n\tnew RegExp(\"no-store\"),\n\tnew RegExp(\"no-cache\")\n];\n\n/**\n * Takes the content of the \"Cache-Control\" HTTP-Header\n * as string and checks if we can cache the request.\n * @sync\n * @memberof cache/valid-cache-control\n * @param {String} the \"Cache-Control\" HTTP-Header's content\n * @return {Boolean} true if it is cacheable, false if not\n */\nconst main = (content) => {\n\tif (typeof (content) !== \"string\" || !content) {\n\t\treturn true;\n\t}\n\treturn ignorePattern.map((regexp) => {\n\t\treturn regexp.test(content);\n\t}).every((match) => {\n\t\treturn match === false;\n\t});\n\n};\n\nexport default main;","/**\n * @module cache/calculate-validity\n * @exports a sync function\n *\n * @description\n * Calculates the timestamp until this cache entry is valid\n * Looks at the Cache-Control Header, the Expires header and finally the default value.\n * Returns a timestamp in ms\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\n/**\n * Calculates the value from the Cache-Control Header.\n * Throws an Error if this is not possible.\n * @sync\n * @memberof cache/calculate-validity\n * @param {String} cacheControlHeaderValue the value of the Cache-Control Header\n * @return {Number|Error} the timestamp until the request should be cached or an Error\n */\nconst _fromCacheControlHeader = (cacheControlHeaderValue, now) => {\n\tif (!cacheControlHeaderValue || !now) {\n\t\tthrow new Error()\n\t}\n\tconst regex = /max-age=([0-9]*)/g;\n\tlet _exec = regex.exec(cacheControlHeaderValue);\n\n\t// no max-age given, look at expires and default\n\tif (!_exec || !_exec[1]) {\n\t\tthrow new Error();\n\t}\n\n\t// max-age given, is it a number? based on the regexp is has to be ...\n\tlet _maxAge;\n\ttry {\n\t\t_maxAge = Number(_exec[1]);\n\t} catch (err) {\n\t\t/* istanbul ignore next */\n\t\tthrow new Error();\n\t}\n\t// but it could be empty ...\n\treturn Number(now + _maxAge);\n};\n\n/**\n * Calculates the value from the Expires Header.\n * Throws an Error if this is not possible.\n * @sync\n * @memberof cache/calculate-validity\n * @param {String} expiresHeaderValue the value of the Expires Header\n * @return {Number|Error} the timestamp until the request should be cached or an Error\n */\nconst _fromExpiresHeader = (expiresHeaderValue) => {\n\tif (!expiresHeaderValue || Number(expiresHeaderValue) <= 0) {\n\t\tthrow new Error();\n\t}\n\t// convert datestring to timestamp\n\tlet _expiresTimestamp = new Date(expiresHeaderValue).getTime();\n\t// check conversion: needs to be numberic, a number, and bigger than zero\n\tif (new RegExp(\"/^[0-9]*$/gm\").test(_expiresTimestamp) || isNaN(_expiresTimestamp) || _expiresTimestamp < 0) {\n\t\tthrow new Error();\n\t}\n\treturn _expiresTimestamp;\n};\n\n\n/**\n * Calculates the value until this request should be cached.\n * Looks at the Cache-Control Header (max-age), the Expires Header\n * and falls back to the default validity from the config\n * @sync\n * @memberof cache/calculate-validity\n * @param {String} cacheControlHeaderValue the value of the Cache-Control Header\n * @param {String} expiresHeaderValue the value of the Expires Header\n * @param {String} defaultValidity the value of the default validity from the configuration\n * @return {Number|Error} the timestamp until the request should be cached\n */\nconst main = (cacheControlHeaderValue, expiresHeaderValue, defaultValidity) => {\n\t// return new Date().getTime() + defaultValidity;\n\tlet _now = new Date().getTime();\n\n\t// cache-control header\n\ttry {\n\t\treturn _fromCacheControlHeader(cacheControlHeaderValue, _now)\n\t} catch (err) {\n\t\t// eslint-disable-line no-empty\n\t\t// catch error, nothing to see, move on\n\t}\n\n\t// expires header\n\ttry {\n\t\treturn _fromExpiresHeader(expiresHeaderValue);\n\t} catch (err) {\n\t\t// eslint-disable-line no-empty\n\t\t// catch error, nothing to see, move on\n\t}\n\n\t// no success - use default value\n\treturn Number(_now + defaultValidity);\n};\n\nexport default main;","\n/**\n * @module cache/valid-content-type\n * @exports a sync function\n *\n * @description\n * Checks if the content-type of the response is valid for LAKKA caching\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\nconst validPattern = [\n\tnew RegExp(\"application/json\"),\n\tnew RegExp(\"text/x-json\"),\n\tnew RegExp(\"text/plain\"),\n\tnew RegExp(\"text/html\")\n];\n\n/**\n * Checks if the content-type of the response indicates a cachable content\n * @sync\n * @memberof cache/valid-content-type\n * @param {String} element the content of the Content-Type header\n * @return {Boolean} true if cachable\n */\nconst main = (content) => {\n\tif (typeof (content) !== \"string\" || !content) {\n\t\treturn false;\n\t}\n\treturn validPattern.map((regexp) => {\n\t\treturn regexp.test(content);\n\t})\n\t\t.some((match) => {\n\t\t\treturn match === true;\n\t\t});\n\n};\n\nexport default main;","/**\n * @module facade/localstorage\n * @exports get()\n * @exports set()\n * @exports del()\n * @exports has()\n * @description\n * The window.localstorage facade\n * This module provides a facade for accessing the internal private cache.\n * In this case: we're using the localStorage\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\n// imports\n\n/**\n * Entry poing for all API functions.\n * Distributes the call to the appropriate action\n * @snyc\n * @memberof facade/localstorage\n * @param {String} action\n * @param {String} key the key for the localStorage item to manipulate\n * @param {String} [value] the value for setting a value\n * @return {Any} the localStorages response\n */\nconst _proxy = (action, key, value) => {\n\tlet _item;\n\tlet _objLakka;\n\tif (!action || !key) {\n\t\tthrow new Error();\n\t}\n\n\ttry {\n\t\tswitch (action) {\n\n\t\t\tcase \"set\":\n\t\t\t\ttry {\n\t\t\t\t\t_objLakka = JSON.parse(window.localStorage.getItem(\"lakka\"));\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// safety net\n\t\t\t\t}\n\n\t\t\t\tif (!_objLakka) {\n\t\t\t\t\t_objLakka = {};\n\t\t\t\t}\n\n\t\t\t\tif ((!value && typeof (value) !== \"string\") && value !== null) {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t}\n\n\t\t\t\t// if (typeof (value) !== \"string\") {\n\t\t\t\t// \tvalue = JSON.stringify(value);\n\t\t\t\t// }\n\n\t\t\t\t// API: del()\n\t\t\t\tif (value === null) {\n\t\t\t\t\tdelete _objLakka[key];\n\t\t\t\t} else {\n\t\t\t\t\t_objLakka[key] = value;\n\t\t\t\t}\n\n\t\t\t\twindow.localStorage.setItem(\"lakka\", JSON.stringify(_objLakka));\n\t\t\t\treturn true;\n\n\n\t\t\tcase \"get\":\n\t\t\t\ttry {\n\t\t\t\t\t_objLakka = JSON.parse(window.localStorage.getItem(\"lakka\"));\n\t\t\t\t} catch (err) {\n\t\t\t\t\t_objLakka = {}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t_item = _objLakka[key] || null;\n\t\t\t\treturn _item;\n\n\t\t\tcase \"del\":\n\t\t\t\treturn _proxy(\"set\", key, null);\n\n\t\t\tcase \"flush\":\n\t\t\t\treturn window.localStorage.setItem(\"lakka\", JSON.stringify({}));\n\t\t}\n\t} catch (err) {\n\t\tthrow new Error(err);\n\t}\n\n}\n\n\n// API\nconst api = {\n\n\t/**\n\t * Retrives a value for a given key or null\n\t * @snyc\n\t * @private\n\t * @memberof facade/localstorage\n\t * @param {String} key the key for the localStorage item to get\n\t * @return {Any} the localStorages response, null if there's no item\n\t */\n\t\"get\": (key) => _proxy(\"get\", key),\n\n\t/**\n\t * Stores a key/value pair\n\t * @snyc\n\t * @private\n\t * @memberof facade/localstorage\n\t * @param {String} key the key for the localStorage item to manipulate\n\t * @param {String} value the value for setting a value\n\t * @return {Any} the localStorages response\n\t */\n\t\"set\": (key, value) => _proxy(\"set\", key, value),\n\n\t/**\n\t * Deletes an item\n\t * @snyc\n\t * @private\n\t * @memberof facade/localstorage\n\t * @param {String} key the key for the localStorage item to delete\n\t * @return {Any} the localStorages response\n\t */\n\t\"del\": (key) => _proxy(\"del\", key),\n\n\t/**\n\t * Flushes the complete cache\n\t * @snyc\n\t * @private\n\t * @memberof facade/localstorage\n\t * @return {Any} the localStorages response\n\t */\n\t\"flush\": () => _proxy(\"flush\", \"*\")\n\n};\n\n\nexport default api;","\n/**\n * @module cache/create-key\n * @exports a sync function\n *\n * @description\n * Creates the key for the cache from the uri\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\n/**\n * Creates the key for the lakka-cache from the URI\n * @sync\n * @memberof cache/create-key\n * @param {String} uri the uri\n * @return {String} the key for this uri\n */\nconst main = (uri) => {\n\tif (typeof (uri) !== \"string\") {\n\t\tthrow new Error();\n\t}\n\n\treturn escape(uri);\n};\nexport default main;\n","/**\n * @module header/utils/get-value\n * @exports a sync function\n *\n * @description\n * Curried function returning the value or \"defaultValue\"\n * for the header-property \"which\" from the \"headers\" object.\n * Handles the the default value fallback and lowercase properties\n *\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\n/**\n * Curried function returning the value or \"defaultValue\"\n * for the header-property \"which\" from the \"headers\" object.\n * Handles the the default value fallback and lowercase properties\n * @curried\n * @sync\n * @memberof cache/create-item\n * @param {Object} headers the headers object\n * @returns {String|null}\n */\nconst main = (headers) =>\n\t/** @param {String} which the name of the header to look for @return {function} */\n\t(which) =>\n\t\t/** @param {Any} [defaultValue] the optional default value  @return {function} */\n\t\t(defaultValue) => {\n\t\t\tif (!headers && defaultValue) { return defaultValue; }\n\t\t\tif (!headers && !defaultValue || !which) { return null; }\n\t\t\tlet value = headers[which] || headers[which.toLowerCase()];\n\t\t\tif (value) { return value; }\n\t\t\tif (!value && defaultValue) { return defaultValue; }\n\t\t\treturn null;\n\t\t};\n\n\nexport default main;\n","\n/**\n * @module cache/create-item\n * @exports a sync function\n *\n * @description\n *\n * Creates a cache-item with\n *\n * \"key\": create-key(uri)\n * \"until\": freshness([default, \"cache-control\", \"expires\"])\n * \"headers\" :\n * \t\t\"X-Status-Code\": 200\n * \t\t\"Cache-Control\":\n * \t\t\"Expires\":\n * \t\t\"Content-Type\": application-type\n * \t\t\"Status\": \"200 from cache\"\n * \"responseText\": string\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\nimport configuration from \"./../configuration/main\";\nimport createKey from \"./../cache/create-key\";\nimport calculateValidity from \"./../cache/calculate-validity.js\";\nimport getHeaderValue from \"./../header/utils/get-value.js\";\n\nconst defaultMinutes = configuration.get(\"minutes\");\nconst defaultMiliseconds = defaultMinutes * 60000;\n\n\n/**\n * Creates the item for the lakka-cache from the URI, responseString and the headers opbject\n * @sync\n * @memberof cache/create-item\n * @param {String} uri the uri\n * @param {String} responseString the response\n * @param {Object} [headers] the optional header object\n * @return {Object} a cache item\n */\nconst main = (uri, responseString, headers) => {\n\t// we're only accepting strings as the first and second and an optional object as third parameter\n\tif (typeof (uri) !== \"string\" || typeof (responseString) !== \"string\" || (headers && headers instanceof Object && headers.constructor === Object) === false) {\n\t\tthrow new Error();\n\t}\n\tlet _item = { \"headers\": {} };\n\ttry {\n\t\t_item.key = createKey(uri);\n\t\t_item.status = 200;\n\t\t_item.statusText = \"cache\"\n\t\t_item.responseText = responseString;\n\t\t_item.until = calculateValidity(getHeaderValue(headers)(\"Cache-Control\")(null), getHeaderValue(headers)(\"Expires\")(null), defaultMiliseconds);\n\t\t_item.headers[\"Status\"] = `${_item.status} ${_item.statusText}`;\n\t\t_item.headers[\"Content-Type\"] = getHeaderValue(headers)(\"Content-Type\")(\"text/plain\");\n\t\t_item.headers[\"Cache-Control\"] = getHeaderValue(headers)(\"Cache-Control\")(null);\n\t\t_item.headers[\"Expires\"] = getHeaderValue(headers)(\"Expires\")(null);\n\t\t// purge\n\t\tObject.keys(_item.headers).forEach((key) => (_item.headers[key] == null) && delete _item.headers[key]);\n\t} catch (err) {\n\t\t// safety net ...\n\t\t/* istanbul ignore next */\n\t\tthrow new Error();\n\t}\n\treturn _item;\n};\n\nexport default main;\n","\n/**\n * @module utils/throw-invalid\n * @exports a sync function\n *\n * @description\n * A small utility function that throws an error if the value evalutes to false\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\n/**\n * A small utility function that throws an error if the value evalutes to false\n * @memberof  * @module utils/throw-invalid\n * @sync\n * @param {Any} value the value to check\n * @return {Any|Error} throws an error if the value evalutes to false\n */\nconst main = (value) => {\n\tif (!value && value !== 0 || value instanceof Error) {\n\t\tthrow new Error();\n\t}\n}\n\n\nexport default main;","/**\n * @module header/utils/checl-value\n * @exports a sync function\n *\n * @description\n * Curried function returning if the value for a \"header\" property\n * inside the \"options.headers\" object is valid as decided by \"fn\"\n *\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\nimport throwIfInvalid from \"./../../utils/throw-invalid\";\n\n/**\n* Curried function returning if the value for a \"header\" property\n* inside the \"options.headers\" object is valid as decided by \"fn\"\n* @curried\n* @sync\n* @param {Function} fn which function to use for validating\n* @return {Boolean|Error} throws an Error if we should ignore this uri, defaults to true even if there's no value\n*/\nconst main = (fn) =>\n\t/** @param {Object} options the options object, contains a headers object @return {function} */\n\t(options) =>\n\t\t/** @param {String} header the header to look up @return {function} */\n\t\t(header) => {\n\t\t\tif (!fn || typeof (fn) !== \"function\") { throw new Error(); }\n\t\t\tif (!options || !options.headers || !header) { return true; }\n\t\t\tlet value = options.headers[header] || options.headers[header.toLowerCase()];\n\t\t\tif (!value) { return true; }\n\t\t\tthrowIfInvalid(fn(value));\n\t\t\treturn true;\n\t\t};\n\nexport default main;\n\n\n","\n/**\n * @module cache/set-item\n * @exports a sync function\n *\n * @description\n *  A Curried function for setting a specific item from a given cache\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\n\nimport throwIfInvalid from \"./../utils/throw-invalid\";\n\n/**\n * Curried function setting the item below \"key\" at \"cache\".\n * @curried\n * @sync\n * @api\n * @param {Object} cache the cache to use\n * @return {Object|Error} the cached item or an Error if we should ignore this uri\n */\nconst main = (cache) =>\n\t/** @param {String} key the key for the lookup @return {function} */\n\t(key) =>\n\t\t/** @param {Object} item the item to store @return {Object} */\n\t\t(item) => {\n\t\t\tthrowIfInvalid(cache.set(key, item));\n\t\t};\nexport default main;\n","\n/**\n * @module pattern/match\n * @exports a sync function\n *\n * @description\n * checks if the given uri matches one of the patterns\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\n/**\n * Checks it the uri is matched the regexp-patterns in the array\n * @param {String} uri the uri\n * @param {Array} patterns an array of regular expressions\n * @return {Boolean} true if there's a match\n */\nconst main = (uri, patterns) => {\n\tif (typeof (uri) !== \"string\" || Array.isArray(patterns) !== true) {\n\t\tthrow new Error();\n\t}\n\n\treturn patterns\n\t\t.map((regexp) => {\n\t\t\treturn regexp.test(uri);\n\t\t})\n\t\t.some((match) => {\n\t\t\treturn match === true;\n\t\t});\n\n};\nexport default main;","\n/**\n * @module api/after\n * @exports a sync function\n * @returns {String|Object|Error} Stores a cache item at the cache if it's a cacheable, valid response\n *\n * @description\n * Handles all the caching steps to be done AFTER receiving the request's response\n *\n * check the status code for success or throw.\n * check the \"Cache-Control\" - header or throw.\n * - Cache if it's \"public\", \"private\", \"Immutable\"\n * - Ignore if \"must-revalidate\", \"no-cache\", \"no-store\", \"proxy-revalidate\"\n * check the \"Expires\", \"Cache-Control\" - Header to see if the content is not already stale (crazy but ppl might use this to prevent caching :/ ) or throw\n * check the \"Content-Type\" or throw\n * create and save the cache item\n * return the cache or throw an error\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\nimport configuration from \"./../configuration/main\";\n\nimport validStatusCode from \"./../header/valid-status-code\";\nimport validCacheControl from \"./../header/valid-cache-control\";\nimport calculateValidity from \"./../cache/calculate-validity\";\nimport validContentType from \"./../header/valid-content-type\";\nimport cache from \"./../facade/localstorage\";\nimport createKey from \"./../cache/create-key\";\nimport createItem from \"./../cache/create-item\";\nimport throwIfInvalid from \"./../utils/throw-invalid\";\nimport getHeaderValue from \"./../header/utils/get-value\";\nimport checkHeaderValue from \"./../header/utils/check-value\";\nimport setToCache from \"./../cache/set-item\";\nimport patternMatch from \"./../pattern-match/main\";\n\nconst defaultMinutes = configuration.get(\"minutes\");\nconst defaultMiliseconds = defaultMinutes * 60000;\n/**\n * Checks if the given URI is part of the include / exclude pattern or throws an Error.\n * @param {String} uri the uri for the request\n * @return {Boolean|Error} throws an Error if we should ignore this uri\n */\nconst _checkPatterns = (uri) => {\n\n\t// get everything from the config\n\tconst _include = configuration.get(\"include\");\n\tconst _exclude = configuration.get(\"exclude\");\n\n\t// the exclude-pattern takes precedent over the include-pattern\n\tif (_exclude.length && patternMatch(uri, _exclude)) {\n\t\tthrow new Error();\n\t}\n\n\t// the include-pattern must be a match if there's an include pattern\n\t// otherwise the include-pattern is not important\n\tif (_include.length && patternMatch(uri, _include) === false) {\n\t\tthrow new Error();\n\t}\n\n\t// no pattern or no failures\n\treturn true;\n};\n\n\n/**\n * Handles all the caching steps to be done AFTER receiving the request's response\n *\n * check the status code for success or throw.\n * check the \"Cache-Control\" - header or throw.\n * - Cache if it's \"public\", \"private\", \"Immutable\"\n * - Ignore if \"must-revalidate\", \"no-cache\", \"no-store\", \"proxy-revalidate\"\n\n * check the \"Expires\", \"Cache-Control\" - Header to see if the content is not already stale (crazy but ppl might use this to prevent caching :/ ) or throw\n * check the \"Content-Type\" or throw\n * create and save the cache item\n * return the cache or throw an error\n *\n * @param {String} uri the uri\n * @param {Object} options the options for this request. eg options.headers.Content-Type\n * @return {Object|Error} the cached item or an Error if this url does not have an item which is stil fresh\n */\nconst main = (uri, responseText, statusCode, options) => {\n\n\t// we're only accepting a String as the first, a String as the second, a Number or String as the third and an Object as the fourth parameter\n\tif (typeof (uri) !== \"string\" ||\n\t\ttypeof (responseText) !== \"string\" ||\n\t\t(typeof (statusCode) !== \"number\" && typeof (statusCode) !== \"string\") ||\n\t\t(options instanceof Object && options.constructor === Object) === false\n\n\t) {\n\t\tthrow new Error();\n\t}\n\n\tconst _statusCode = String(statusCode);\n\n\ttry {\n\t\t// we need to check if the given URI is part of the include / exclude pattern or throw.\n\t\t_checkPatterns(uri);\n\t\t// check if the status code indicates a successful request\n\t\tthrowIfInvalid(validStatusCode(_statusCode));\n\t\t// check if the cache control header let's us cache this request\n\t\tcheckHeaderValue(validCacheControl)(options)(\"Cache-Control\");\n\t\t// check if the content-type is a cachable one\n\t\tcheckHeaderValue(validContentType)(options)(\"Content-Type\");\n\t\t// check if the expires header has a future date or there's no expires header\n\t\tthrowIfInvalid(calculateValidity(\"\", getHeaderValue(options.headers)(\"Expires\")(null), defaultMiliseconds) >= Date.now());\n\n\t} catch (err) {\n\t\tthrow new Error();\n\t}\n\n\t// write to cache\n\tlet _item;\n\ttry {\n\t\t_item = createItem(uri, responseText, options.headers);\n\t\tsetToCache(cache)(createKey(uri))(_item);\n\t} catch (err) {\n\t\t// just a safety net\n\t\t/* istanbul ignore next */\n\t\tthrow new Error();\n\t}\n\n\treturn _item;\n\n};\n\nexport default main;\n","\n/**\n * @module cache/check-freshness\n * @exports a sync function\n *\n * @description\n *  Checks if a cache item is still fresh\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\n\n/**\n * Checks if a cache item is still fresh\n * @sync\n * @api\n * @param {Object} cacheItem che cache item\n * @return {Boolean} true if still fresh\n */\nconst main = (cacheItem) => !!(cacheItem && cacheItem.until && cacheItem.until >= Date.now());\nexport default main;\n","\n/**\n * @module cache/get-item\n * @exports a sync function\n *\n * @description\n *  A Curried function for getting a specific item from a given cache\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\nimport checkFreshness from \"./../cache/check-freshness.js\";\n\n/**\n * Curried function returning the item stored below \"key\" from \"cache\".\n * @curried\n * @sync\n * @api\n * @param {Object} cache the cache to use\n * @return {Object|Error} the cached item or an Error if we should ignore this uri\n */\nconst main = (cache) =>\n\t/** @param {String} key the key for the lookup @return {function} */\n\t(key) => {\n\t\tconst item = cache.get(key);\n\t\t// is there a fresh item?\n\t\tif (!checkFreshness(item)) {\n\t\t\t// purge cache\n\t\t\tcache.del(key)\n\t\t\t// throw;\n\t\t\tthrow new Error();\n\t\t}\n\t\treturn item;\n\t};\nexport default main;\n","\n/**\n * @module api/before\n * @exports a sync function\n * @returns {Object|Error} Returns the cached response item or throws an Error if the cache is empy or stale\n *\n * @description\n * Handles all the caching steps to be done BEFORE sending a request:\n *\n * check the include / exclude pattern or throw.\n * check the cache-control Header or throw.\n * check the accept Header or throw.\n * check the contentType Header or throw.\n * create the $KEY with escape()\n * check if the localStorage contains a $RESPONSE for $KEY or throw.\n * check for a stale cache by looking at the $TIMESTAMP or throw.\n * return the cached $RESPONSE for $KEY in appropritate format if it's not stale\n * or throw and make the request because the cache is stale or empty or not used\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\nimport configuration from \"./../configuration/main\";\nimport patternMatch from \"./../pattern-match/main\";\nimport validCacheControl from \"./../header/valid-cache-control\";\nimport validContentType from \"./../header/valid-content-type\";\nimport cache from \"./../facade/localstorage\";\nimport createKey from \"./../cache/create-key\";\nimport checkHeaderValue from \"./../header/utils/check-value\";\nimport getFromCache from \"./../cache/get-item\";\n\n/**\n * Checks if the given URI is part of the include / exclude pattern or throws an Error.\n * @param {String} uri the uri for the request\n * @return {Boolean|Error} throws an Error if we should ignore this uri\n */\nconst _checkPatterns = (uri) => {\n\n\t// get everything from the config\n\tconst _include = configuration.get(\"include\");\n\tconst _exclude = configuration.get(\"exclude\");\n\n\t// the exclude-pattern takes precedent over the include-pattern\n\tif (_exclude.length && patternMatch(uri, _exclude)) {\n\t\tthrow new Error();\n\t}\n\n\t// the include-pattern must be a match if there's an include pattern\n\t// otherwise the include-pattern is not important\n\tif (_include.length && patternMatch(uri, _include) === false) {\n\t\tthrow new Error();\n\t}\n\n\t// no pattern or no failures\n\treturn true;\n};\n\n/**\n * Handles all the caching steps to be done BEFORE sending a request:\n *\n * check the include / exclude pattern\n * check the cache-control Header\n * check the accept Header\n * check the contentType Header\n * create the $KEY with escape()\n * check if the localStorage contains a $RESPONSE for $KEY\n * check for a stale cache by looking at the $TIMESTAMP\n * return the cached $RESPONSE for $KEY in appropritate format if it's not stale\n * or throw and make the request because the cache is stale or empty or not used\n *\n * @param {String} uri the uri\n * @param {Object} options the options for this request. eg options.headers.Content-Type\n * @return {Object|Error} the cached item or an Error if this url does not have an item which is stil fresh\n */\nconst main = (uri, options) => {\n\t// we're only accepting strings as the first and an optional object as second parameter\n\tif (typeof (uri) !== \"string\" || (options && options instanceof Object && options.constructor === Object) === false) {\n\t\tthrow new Error();\n\t}\n\ttry {\n\t\t// we need to check if the given URI is part of the include / exclude pattern or throw.\n\t\t_checkPatterns(uri);\n\t\t// check if the cache control header let's us handle this request\n\t\tcheckHeaderValue(validCacheControl)(options)(\"Cache-Control\");\n\t\t// check if the accept header let's us handle this request\n\t\tcheckHeaderValue(validContentType)(options)(\"Accept\");\n\t\t// check if the content-type header let's us handle this request\n\t\tcheckHeaderValue(validContentType)(options)(\"Content-Type\");\n\t\t// check the cache for cached content which is still fresh\n\t\treturn getFromCache(cache)(createKey(uri));\n\n\t} catch (err) {\n\t\tthrow new Error();\n\t}\n\n};\nexport default main;","/**\n * @module api/main\n * @exports a sync function \"ignore\"\n * @exports a sync function \"configuration\"\n *\n * @exports a sync function \"after\"\n * @exports a sync function \"before\"\n *\n * @description\n * Defines the publicly exposed API\n * - ignore:\n * \t\tAdds an ignore pattern (a string / RegEx) to the existing / default configuration\n * \t\turls matching this pattern will be ignored by the lakka cache and passed throught\n * - recognize:\n * \t\tAdds an include pattern (a string / RegEx) to the existing / default configuration\n * \t\turls matching this pattern will be recognized by the lakka cache and passed throught\n * \t\tig this is empty, all URIs will be recognized\n * - time:\n * \t\tSets the minutes (Number) we should cache items for. Defaut value is 60 minutes.\n * \t\tWill be overwritten by the \"max-age\" - value of the Cache-Control Header or the Expires Header\n * \t\tof the response.\n * - configuration:\n * \t\tAdds a complete configuration object with \"ignore\", \"exclude\", \"minutes\"\n * - after:\n * \t\tCall this after the actual request. Checks the response and store it at the cache. Returns the cache item or an error.\n * - before:\n * \t\tCall this before the actual request. Checks for and returns a fresh cache item or an error.\n *\n * @copyright 2017 Martin Krause <github@mkrause.info> (http://martinkr.github.io)\n * @license MIT license: https://opensource.org/licenses/MIT\n *\n * @author Martin Krause <github@mkrause.info>\n */\n\nimport after from \"./../api/after\";\nimport before from \"./../api/before\";\nimport cacheFacade from \"./../facade/localstorage\";\nimport configuration from \"./../configuration/main\";\n\n// API\nconst api = {\n\n\t/**\n\t * Sets the minutes (Number) we should cache items for. Defaut value is 60 minutes.\n\t * Will be overwritten by the \"max-age\" - value of the Cache-Control Header or the Expires Header\n\t * of the response.\n\t * @sync\n\t * @public\n\t * @memberof api/time\n\t * @param {Number} value the default caching time\n\t * @return {Any} the configuration value\n\t */\n\t\"time\": (value) => configuration.set(\"minutes\", value),\n\n\t/**\n\t * Dynamically add an \"exclude\" pattern to the lakka cache.\n\t * Any matches for this pattern will be ignored by the lakka cache.\n\t * @sync\n\t * @public\n\t * @memberof api/ignore\n\t * @param {String|Regex} pattern the pattern or regexp to check the uri against. Any matches will be ignored by the lakka cache.\n\t * @return {Any} the configuration value\n\t */\n\t\"ignore\": (pattern) => configuration.set(\"exclude\", pattern),\n\n\t/**\n\t * Dynamically add an \"include\" pattern to the lakka cache.\n\t * Any matches for this pattern will be ignored by the lakka cache.\n\t * @sync\n\t * @public\n\t * @memberof api/recognize\n\t * @param {String|Regex} pattern the pattern or regexp to check the uri against. Any matches will be recognized and handled by the lakka cache.\n\t * @return {Any} the configuration value\n\t */\n\t\"recognize\": (pattern) => configuration.set(\"include\", pattern),\n\n\t/**\n\t * Dynamically merge a configuration object into the current / default configuraiton object.\n\t * \"include\"/\"exclude\" will be merged, \"minutes\" will be replaced\n\t * @sync\n\t * @public\n\t * @memberof api/configuration\n\t * @param {Object} obj a configuration object\n\t * @return {Any} the configuration value\n\t */\n\t\"configuration\": (obj) => configuration.set(obj),\n\n\t/**\n\t * Force clear an item from the cache.\n\t * @sync\n\t * @public\n\t * @memberof api/remove\n\t * @param {String} uri the uri to remove\n\t * @return {Any} the configuration value\n\t */\n\t\"remove\": (uri) => cacheFacade.del(uri),\n\n\n\t/**\n\t * Flush the lakka cache. Remove all items\n\t * @sync\n\t * @public\n\t * @memberof api/configuration\n\t * @return {Any} the configuration value\n\t */\n\t\"flush\": () => cacheFacade.flush(),\n\n\n\t/**\n\t * Handles all the caching steps to be done AFTER receiving the request's response\n\t *\n\t * check the status code for success or throw.\n\t * check the \"Cache-Control\" - header or throw.\n\t * - Cache if it's \"public\", \"private\", \"Immutable\"\n\t * - Ignore if \"must-revalidate\", \"no-cache\", \"no-store\", \"proxy-revalidate\"\n\n\t* check the \"Expires\", \"Cache-Control\" - Header to see if the content is not already stale (crazy but ppl might use this to prevent caching :/ ) or throw\n\t* check the \"Content-Type\" or throw\n\t* create and save the cache item\n\t* return the cache or throw an error\n\t*\n\t* @sync\n\t* @public\n\t* @memberof api/after\n\t* @param {String} uri the uri\n\t* @param {Object} options the options for this request. eg options.headers.Content-Type\n\t* @return {Object|Error} the cached item or an Error if this url does not have an item which is stil fresh\n\t*/\n\t\"after\": (uri, responseText, statusCode, options) => after(uri, responseText, statusCode, options),\n\n\n\t/**\n\t * Handles all the caching steps to be done BEFORE sending a request:\n\t *\n\t * check the include / exclude pattern\n\t * check the cache-control Header\n\t * check the accept Header\n\t * check the contentType Header\n\t * create the $KEY with escape()\n\t * check if the localStorage contains a $RESPONSE for $KEY\n\t * check for a stale cache by looking at the $TIMESTAMP\n\t * return the cached $RESPONSE for $KEY in appropritate format if it's not stale\n\t * or throw and make the request because the cache is stale or empty or not used\n\t *\n\t * @sync\n\t * @public\n\t * @memberof api/before\n\t * @param {String} uri the uri\n\t * @param {Object} options the options for this request. eg options.headers.Content-Type\n\t * @return {Object|Error} the cached item or an Error if this url does not have an item which is stil fresh\n\t */\n\t\"before\": (uri, options) => before(uri, options)\n\n};\n\n\nexport default api;","\nimport api from './api/main';\n\nconst time = api[\"time\"];\nconst ignore = api[\"ignore\"];\nconst recognize = api[\"recognize\"];\nconst configuration = api[\"configuration\"];\nconst remove = api[\"remove\"];\nconst flush = api[\"flush\"];\nconst after = api[\"after\"];\nconst before = api[\"before\"];\n\nexport {\n    time,\n    ignore,\n    recognize,\n    configuration,\n    remove,\n    flush,\n    after,\n    before\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","validProperties","config","assign","defaults","_set","args","filter","element","length","keys","every","includes","Number","isNaN","Array","isArray","_validArguments","Error","RegExp","some","source","push","_get","ignorePattern","content","map","regexp","test","match","cacheControlHeaderValue","expiresHeaderValue","defaultValidity","_now","Date","getTime","now","_maxAge","_exec","exec","err","_fromCacheControlHeader","_expiresTimestamp","_fromExpiresHeader","validPattern","_proxy","action","_objLakka","JSON","parse","window","localStorage","getItem","setItem","stringify","uri","escape","headers","which","defaultValue","toLowerCase","defaultMiliseconds","configuration","responseString","constructor","_item","createKey","status","statusText","responseText","until","calculateValidity","getHeaderValue","forEach","fn","options","header","throwIfInvalid","cache","item","set","patterns","_checkPatterns","_include","_exclude","patternMatch","statusCode","_statusCode","String","validStatusCode","checkHeaderValue","validCacheControl","validContentType","createItem","setToCache","cacheItem","checkFreshness","del","getFromCache","api","pattern","cacheFacade","after","before","time","ignore","recognize","remove","flush"],"sourceRoot":""}